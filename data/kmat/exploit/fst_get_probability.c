//#define DEBUG

#include <string.h>
#include <stdio.h>

#include "probtool.h"
#include "dafst.h"
#include "bin2txt.h"

#define PROBcMAXSTR 1024
///////////////////////////////////////////////////////////////////////////////
/* Target : 분자 */
// P(Target)
double prob_GetFSTProb1
(
	PROBtFST *ProbFst,
	char *Target
) 
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];
	
	sprintf( str_to_find, "%s%c%s", Target, PROBcDELIM_INTER, PROBcNULLSTRING);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return PROBcLOG_ALMOST_ZERO; /* 거의 0 */
	}
	else
	{
		return ((double) (ProbFst->prob)[n]);
		
		//for (i = 0; i < num_index; i++) { // 복수개의 분석 결과가 있을 경우
		//	// 출력 : 인덱스번호, 문자열, 카테고리, 빈도
		//	return (fst_prob[n]);
		//	n++; // 증가
		//}
	}
}

///////////////////////////////////////////////////////////////////////////////
// P(Target | T4)
double prob_GetFSTProb2
(
	PROBtFST *ProbFst,
	char *Target, 
	char *T4
) 
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];
	
	sprintf( str_to_find, "%s%c%s", Target, PROBcDELIM_INTER, T4);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
#ifdef DEBUG
		fprintf( stdout, "[%s] not found! (%s)\n", str_to_find, __FILE__);
#endif
		return prob_GetFSTProb1( ProbFst, Target);
	}
	else
	{
#ifdef DEBUG
		fprintf( stdout, "[%s] found! (%s)\n", str_to_find, __FILE__);
#endif
		return ((double) (ProbFst->prob)[n]);
	}
}

///////////////////////////////////////////////////////////////////////////////
/* Target : 분자 */
/* T3+T4 : 분모 */
double prob_GetFSTProb3
(
	PROBtFST *ProbFst,
	char *Target, 
	char *T3, 
	char *T4
)
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];
	
	sprintf( str_to_find, "%s%c%s%c%s", Target, PROBcDELIM_INTER, T3, PROBcDELIM_INTRA, T4);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return prob_GetFSTProb2( ProbFst, Target, T4);
	}
	else
	{
		return ((double)(ProbFst->prob)[n]);
	}
}

///////////////////////////////////////////////////////////////////////////////
/* Target : 분자 */
/* T2+T3+T4 : 분모 */
double prob_GetFSTProb4
(
	PROBtFST *ProbFst,
	char *Target, 
	char *T2, 
	char *T3, 
	char *T4
) 
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];
	
	sprintf( str_to_find, "%s%c%s%c%s%c%s", Target, PROBcDELIM_INTER, T2, PROBcDELIM_INTRA, T3, PROBcDELIM_INTRA, T4);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return prob_GetFSTProb3( ProbFst, Target, T3, T4);
	}
	else
	{
		return ((double)(ProbFst->prob)[n]);
	}
}

///////////////////////////////////////////////////////////////////////////////
/* Target : 분자 */
/* T1+T2+T3+T4 : 분모 */
double prob_GetFSTProb5
(
	PROBtFST *ProbFst,
	char *Target, 
	char *T1, 
	char *T2, 
	char *T3, 
	char *T4
) 
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];

	sprintf( str_to_find, "%s%c%s%c%s%c%s%c%s", Target, PROBcDELIM_INTER, T1, PROBcDELIM_INTRA, T2, PROBcDELIM_INTRA, T3, PROBcDELIM_INTRA, T4);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return prob_GetFSTProb4( ProbFst, Target, T2, T3, T4);
	}
	else
	{
		return ((double)(ProbFst->prob)[n]);
	}
}

///////////////////////////////////////////////////////////////////////////////
// P[Left][Right]
// P( Left | Right)를 의미하는 것은 아님
double prob_GetFSTProbMLE
(
	PROBtFST *ProbFst,
	char *Left,
	char *Right
)
{
	int n;
	int num_index;
	char *right_temp;
	int i;
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst->fst, (char *)Left, &num_index))== (-1)) // 없으면
	{
		return PROBcLOG_ALMOST_ZERO;
	}
	else // 있으면
	{
		for (i = 0; i < num_index; i++)
		{
			right_temp = b2t_GetString( ProbFst->info, n+i);
			if (strcmp( Right, right_temp) == 0) // 같으면
			{
				return ((double)(ProbFst->prob)[n+i]);
			}
		}
		// for 문을 빠져나온 경우 : left는 있으나 right는 없는 경우
		return PROBcLOG_ALMOST_ZERO;
	}
}

///////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////
/* Target : 분자 */
// P(Target)
double prob_GetFSTProb1a
(
	PROBtFST *ProbFst[],
	char *Target
) 
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];
	
	sprintf( str_to_find, "%s%c%s", Target, PROBcDELIM_INTER, PROBcNULLSTRING);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst[0]->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return PROBcLOG_ALMOST_ZERO; /* 거의 0 */
	}
	else
	{
		return ((double)(ProbFst[0]->prob)[n]);
		
		//for (i = 0; i < num_index; i++) { // 복수개의 분석 결과가 있을 경우
		//	// 출력 : 인덱스번호, 문자열, 카테고리, 빈도
		//	return (fst_prob[n]);
		//	n++; // 증가
		//}
	}
}

///////////////////////////////////////////////////////////////////////////////
// P(Target | T4)
double prob_GetFSTProb2a
(
	PROBtFST *ProbFst[],
	char *Target, 
	char *T4
) 
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];
	
	sprintf( str_to_find, "%s%c%s", Target, PROBcDELIM_INTER, T4);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst[1]->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return prob_GetFSTProb1a( ProbFst, Target);
	}
	else
	{
		return ((double)(ProbFst[1]->prob)[n]);
	}
}

///////////////////////////////////////////////////////////////////////////////
/* Target : 분자 */
/* T3+T4 : 분모 */
double prob_GetFSTProb3a
(
	PROBtFST *ProbFst[],
	char *Target, 
	char *T3, 
	char *T4
)
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];
	
	sprintf( str_to_find, "%s%c%s%c%s", Target, PROBcDELIM_INTER, T3, PROBcDELIM_INTRA, T4);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst[2]->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return prob_GetFSTProb2a( ProbFst, Target, T4);
	}
	else
	{
		return ((double)(ProbFst[2]->prob)[n]);
	}
}

///////////////////////////////////////////////////////////////////////////////
/* Target : 분자 */
/* T2+T3+T4 : 분모 */
double prob_GetFSTProb4a
(
	PROBtFST *ProbFst[],
	char *Target, 
	char *T2, 
	char *T3, 
	char *T4
) 
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];
	
	sprintf( str_to_find, "%s%c%s%c%s%c%s", Target, PROBcDELIM_INTER, T2, PROBcDELIM_INTRA, T3, PROBcDELIM_INTRA, T4);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst[3]->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return prob_GetFSTProb3a( ProbFst, Target, T3, T4);
	}
	else
	{
		return ((double)(ProbFst[3]->prob)[n]);
	}
}

///////////////////////////////////////////////////////////////////////////////
/* Target : 분자 */
/* T1+T2+T3+T4 : 분모 */
double prob_GetFSTProb5a
(
	PROBtFST *ProbFst[],
	char *Target, 
	char *T1, 
	char *T2, 
	char *T3, 
	char *T4
) 
{
	int n;
	int num_index;
	char str_to_find[PROBcMAXSTR];

	sprintf( str_to_find, "%s%c%s%c%s%c%s%c%s", Target, PROBcDELIM_INTER, T1, PROBcDELIM_INTRA, T2, PROBcDELIM_INTRA, T3, PROBcDELIM_INTRA, T4);
	
	// 문자열 -> 인덱스(해쉬)값
	if ((n = fst_String2Hash( ProbFst[4]->fst, str_to_find, &num_index))== (-1)) // 없으면
	{
		return prob_GetFSTProb4a( ProbFst, Target, T2, T3, T4);
	}
	else
	{
		return ((double)(ProbFst[4]->prob)[n]);
	}
}
