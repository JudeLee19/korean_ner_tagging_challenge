#include <stdio.h>
#include <string.h>
#include <assert.h>
#include <ctype.h>
#include "hsplit.h"


//      매크로
#define UHCmSCOPE(x,low,high)   ( (x) >= (low) && (x) <= (high))

const char *UHCcCTYPE[] = 
{
	"ASC_NULL",
	"ASC_CONTROL",
	"ASC_DIGIT",
	"ASC_ALPHA", 
	"ASC_PUNCT", 
	"ASC_UNKNOWN",
	"UHC_UNKNOWN",
	"UHC_HANGEUL",
	"UHC_DIGIT",
	"UHC_LATIN", 
	"UHC_JAEUM",
	"UHC_MOEUM",
	"UHC_FILLER",
	"UHC_YESJAEUM",
	"UHC_YESMOEUM",
	"UHC_GREEK",
	"UHC_BOXDRAW",
	"UHC_HIRAGANA",
	"UHC_KATAKANA",
	"UHC_CYRIL",
	"UHC_USERAREA",
	"UHC_HANJA", 
	"UHC_SYMBOL", 
};

////////////////////////////////////////////////////////////////////////////////
//      [UHC_GetCharType]     문자열 중에서 첫글자의 문자타입을 리턴
//
//      -       한글 음절       -->     KSX-1001, UHC
//      -       한글 자모       -->     KSX-1001
//      -       라틴어          -->     ASCII, KSX-1001
//      -       그리스어        -->     KSX-1001
//      -       키릴어          -->     KSX-1001
//      -       기호            -->     ASCII, KSX-1001
//      -       한자            -->     KSX-1001
//      -       일본어          -->     KSX-1001
//      -       선문자          -->     KSX-1001
//      -       사용자영역      -->     KSX-1001
//      -       나머지는 그룹의 첫번째 문자의 코드값을 타입으로 사용
//
int	UHC_GetCharType	// [리턴]  첫글자 문자타입
(
	const unsigned char *Str	// [입력]	문자열
)
{
	assert( Str != NULL);

	// ASCII에 대한 처리 먼저!!
	if( *Str == '\0') return ASC_NULL;
	if( *Str < 0x80)
	{
		if( isalpha( *Str)) return ASC_ALPHA;
		if( isdigit( *Str)) return ASC_DIGIT;
		if( iscntrl( *Str)) return ASC_CONTROL;
		if( ispunct( *Str)) return ASC_PUNCT;
		return ASC_UNKNOWN;
	}
	
	// 0x80이상인 코드의 뒤가 '\0'이면 Control 문자로 간주
	if( *(Str + 1) == '\0') return ASC_CONTROL;
	
	// 한글 음절
	if( UHCmSCOPE( *Str, 0x81, 0xA0) || UHCmSCOPE( *Str, 0xB0, 0xC5))
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xFE)) return UHC_HANGEUL;
		
		return UHC_UNKNOWN;
	}
	
	if( UHCmSCOPE( *Str, 0xAD, 0xAF))
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xC6)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x52)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xFE)) return UHC_HANGEUL;
		
		return UHC_UNKNOWN;
	}
	
	if( UHCmSCOPE( *Str, 0xC7, 0xC8))
	{
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xFE)) return UHC_HANGEUL;
		
		return UHC_UNKNOWN;
	}
	
	// 한자
	if( UHCmSCOPE( *Str, 0xCA, 0xFD))
	{
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xFE)) return UHC_HANJA;
		
		return UHC_UNKNOWN;
	}
	
	// 사용자 영역
	if( *Str == 0xC9 || *Str == 0xFE)
	{
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xFE)) return UHC_USERAREA;
		
		return UHC_UNKNOWN;
	}
	
	// 기타 혼합 영역
	if( *Str == 0xA1)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xFE)) return UHC_SYMBOL; //return *(Str + 1) | 0xA100;
		
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xA2)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xE7)) return UHC_SYMBOL; //return *(Str + 1) | 0xA200;
		
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xA3)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xB0, 0xB9)) return UHC_DIGIT;
		if( UHCmSCOPE( *(Str + 1), 0xC1, 0xDA)) return UHC_LATIN; // 대문자
		if( UHCmSCOPE( *(Str + 1), 0xE1, 0xFA)) return UHC_LATIN; // 소문자
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xAF) ||
			UHCmSCOPE( *(Str + 1), 0xBA, 0xC0) ||
			UHCmSCOPE( *(Str + 1), 0xDB, 0xE0) ||
			UHCmSCOPE( *(Str + 1), 0xFB, 0xFE))	return UHC_SYMBOL; //return *(Str + 1) | 0xA300;
			
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xA4)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xBE)) return UHC_JAEUM;
		if( UHCmSCOPE( *(Str + 1), 0xBF, 0xD3)) return UHC_MOEUM;
		if( UHCmSCOPE( *(Str + 1), 0xD5, 0xF6)) return UHC_YESJAEUM;
		if( UHCmSCOPE( *(Str + 1), 0xF7, 0xFE)) return UHC_YESMOEUM;
		if( *(Str + 1) == 0xD4) return UHC_FILLER;
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xA5)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xC1, 0xD8)) return UHC_GREEK; // 대문자
		if( UHCmSCOPE( *(Str + 1), 0xE1, 0xF8)) return UHC_GREEK; // 소문자
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xAA) 
			|| UHCmSCOPE( *(Str + 1), 0xB0, 0xB9)) return UHC_SYMBOL; //return *(Str + 1) | 0xA500;
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xA6)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xE4)) return UHC_BOXDRAW;
		
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xA7)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xEF)) return UHC_SYMBOL; //return *(Str + 1) | 0xA700;
		
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xA8)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xA4) || *(Str + 1) == 0xA6 ||
			UHCmSCOPE( *(Str + 1), 0xA8, 0xAF) ||
			UHCmSCOPE( *(Str + 1), 0xB1, 0xFE)) return UHC_SYMBOL; //return *(Str + 1) | 0xA800;
			
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xA9)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xFE)) return UHC_SYMBOL; //return *(Str + 1) | 0xA900;
		
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xAA)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xF3)) return UHC_HIRAGANA;
		
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xAB)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xF6)) return UHC_KATAKANA;
		
		return UHC_UNKNOWN;
	}
	
	if( *Str == 0xAC)
	{
		if( UHCmSCOPE( *(Str + 1), 0x41, 0x5A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x61, 0x7A)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0x81, 0xA0)) return UHC_HANGEUL;
		if( UHCmSCOPE( *(Str + 1), 0xA1, 0xC1)) return UHC_CYRIL; // 대문자
		if( UHCmSCOPE( *(Str + 1), 0xD1, 0xF1)) return UHC_CYRIL; // 소문자
		
		return UHC_UNKNOWN;
	}
	
	return UHC_UNKNOWN;
}

////////////////////////////////////////////////////////////////////////////////
/* 주어진 문자열(source_str)을 1차 문자 배열로 된 문자열(target_str)로 변환 */
/* 1 byte 문자는 앞에 FIL을 유지 */
extern int convert_str(int num_char, char source_str[][3], char *target_str) {
	int i;
	int j = 0;
	
	target_str[0] = 0;
	
	for (i = 0; i < num_char; i++) {
		target_str[j++] = source_str[i][0];
		target_str[j++] = source_str[i][1];
	}
	target_str[j] = 0;
	
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
/* 주어진 문자열(source_str)을 1차 문자 배열로 된 문자열(target_str)로 변환 */
/* 1 byte 문자는 앞에 FIL을 제거 */
extern int convert_str_origin(int num_char, char source_str[][3], char *target_str) {
	int i;
	int j = 0;
	
	target_str[0] = 0;
	
	for (i = 0; i < num_char; i++) {

		if (source_str[i][0] != FIL && source_str[i][0] != FIL2) {
			target_str[j++] = source_str[i][0];
		}
		else i++;

		target_str[j++] = source_str[i][1];
	}

	target_str[j] = 0;
	
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
/* 주어진 문자열(source_str)을 문자열(target_str)로 변환 */
/* 1 byte 문자는 앞에 FIL을 제거 */
extern int convert_str_origin_array(char *source_str, char *target_str) {
	int i;
	int j = 0;
	int len;

	len = (int) strlen(source_str);

	for (i = 0; i < len; i++) {
		if (source_str[i] != FIL && source_str[i] != FIL2) {
			target_str[j++] = source_str[i];
		}
	}
	target_str[j] = 0;

	return 1;
}

////////////////////////////////////////////////////////////////////////////////
static int pushWord(word_type *sword, char *word, int type, int *count)
{
	if (*count < MAX_SPLIT) {
		strcpy(sword[*count].word, word);
		sword[*count].type = type;
		(*count)++;
		return 1;
	}
	
	return 0;
}

////////////////////////////////////////////////////////////////////////////////
/* this function analyze a given string into several partable including Korean
	 word-phrase, English string, digit string, punctuation, Chinese string,
	 pictorial string, and so on. */
/* 완성형 */
int split_by_word_type (word_type *sword, char *hword) {
	char word[MAX_WORD];
	unsigned char* w;
	int start;
	int type;
	int len;
	int wi;
	int count=0;
	
	len = (int) strlen (hword);
	
	if(len >= MAX_WORD) {
		 fprintf(stderr, "[Warning: Too long word] %s\n", hword);
		 return 0;
	}
	
	wi = 0;
	w = (unsigned char*) hword;
	
	while (wi < len) {
		start = wi;
		if (isascii(w[wi])) { /* 아스키 코드인가? */
			if (isupper(w[wi])) { /* 알파벳인가? */
				/* foreign language - english */
				while (wi < len && isupper (w[wi])) wi++;
				strncpy (word, hword+start, wi-start);
				word[wi-start] = 0;
				type = T_ENG_UPPER; /* 외국어 대문자 */
			} 
			else if (islower(w[wi])) { /* 알파벳인가? */
				/* foreign language - english */
				while (wi < len && islower (w[wi])) wi++;
				strncpy (word, hword+start, wi-start);
				word[wi-start] = 0;
				type = T_ENG_LOWER; /* 외국어 소문자 */
			} 
			else if (isdigit (w[wi])) { /* 숫자인가? */
				/* digit */
				while (wi < len && isdigit (w[wi])) wi++;
				strncpy (word, hword+start, wi-start);
				word[wi-start] = 0;
				type = T_DIG; /* 수사 */
			} 
			else if (w[wi] == FIL) { /* FIL 인가? */
				while (wi < len && w[wi] == FIL) wi++;
				strncpy (word, hword+start, wi-start);
				word[wi-start] = 0;
				type = T_FIL; /* 수사 */
			} 
			else { /* 그밖의 문자 */
				while (wi < len && isascii(w[wi]) && !isdigit(w[wi]) && !isalpha(w[wi]) ) wi++;
				strncpy (word, hword+start, wi-start);
				word [wi-start] = 0;
				type = T_SYM;			/* 기호 */
			} 
		} 
		else { /* 한글 또는 한자 또는 2바이트 문자 */
			if (isHangul(w[wi], w[wi+1])) { /* 한글인가? */
				/* korean */
				while (wi < len && isHangul(w[wi], w[wi+1])) { 
					wi += 2;
				}
				{
					strncpy (word, hword+start, wi-start);
					word [wi-start] = 0;
					type = T_HAN; /* 한글 */
				}
			} 
			else if (isHanja(w[wi], w[wi+1])) { /* 한자인가? */
				/* hanja */
				while (wi < len && isHanja(w[wi], w[wi+1])) wi += 2;
				strncpy (word, hword+start, wi-start);
				word [wi-start] = 0;
				type = T_HJ; /* 자립 명사 */
			} 
			else { /* 2바이트 문자 */
				word [0] = hword [wi++];
				word [1] = hword [wi++];
				word [2] = 0;
				type = T_2BSYM; /* 2 byte 기호 */
			}
		}
		
		/* 조각난 단어 및 유형 저장 */
		if (!pushWord(sword, word, type, &count)) return 0;
	}
	
	return count;
}

////////////////////////////////////////////////////////////////////////////////
/* 주어진 문자열을 각 문자별로 나눈다. */
/* hword = 입력 문자열 */
/* splitchar = 결과 저장 */
/* 1 byte 문자는 앞에 FIL을 붙여서 2byte로 만든다. */
/* return value : 분리된 문자의 수 */
int split_by_char (char *hword, char splitchar[][3]) {
	unsigned char* w = (unsigned char*) hword;
	int len = (int) strlen (hword);
	int wi = 0;
	int num_splitchar = 0;
	
	while (wi < len) {
		if (isascii(w[wi])) { /* 아스키 코드인가? */
			splitchar[num_splitchar][0] = FIL;
			splitchar[num_splitchar][1] = w[wi++];
			splitchar[num_splitchar++][2] = 0;
		} 
		else { /* 한글 또는 한자 또는 2바이트 문자 */
			splitchar[num_splitchar][0] = w[wi++];
			splitchar[num_splitchar][1] = w[wi++];
			splitchar[num_splitchar++][2] = 0;
		}
	}
	
	return num_splitchar;
}

////////////////////////////////////////////////////////////////////////////////
/* 주어진 문자열을 각 문자별로 나눈다. */
/* hword = 입력 문자열 */
/* splitchar = 결과 저장 */
/* 1 byte 문자는 앞에 FIL을 제거 */
/* return value : 분리된 문자의 수 */
int split_by_char_origin (char *hword, char splitchar[][3]) {
	unsigned char* w = (unsigned char*) hword;
	int len = (int) strlen (hword);
	int wi = 0;
	int num_splitchar = 0;
	
	while (wi < len) {
		if (isascii(w[wi])) { /* 아스키 코드인가? */
			splitchar[num_splitchar][0] = w[wi++];
			splitchar[num_splitchar++][1] = 0;
		} 
		else { /* 한글 또는 한자 또는 2바이트 문자 */
			splitchar[num_splitchar][0] = w[wi++];
			splitchar[num_splitchar][1] = w[wi++];
			splitchar[num_splitchar++][2] = 0;
		}
	}
	
	return num_splitchar;
}

////////////////////////////////////////////////////////////////////////////////
/* 주어진 문자열을 각 문자별로 나눈다. */
/* hword = 입력 문자열 */
/* splitchar = 결과 저장 */
/* 1 byte 문자는 앞에 FIL을 붙여서 2byte로 만든다. */
/* return value : 성공 = 1 */
int split_by_char_array (char *hword, char *splitchar) {
	unsigned char* w = (unsigned char*) hword;
	int len = (int) strlen (hword);
	int wi = 0;
	int i = 0;
	
	while (wi < len) {
		if (isascii(w[wi])) { /* 아스키 코드인가? */
			splitchar[i++] = FIL;
			splitchar[i++] = w[wi++];
		} 
		else { /* 한글 또는 한자 또는 2바이트 문자 */
			splitchar[i++] = w[wi++];
			splitchar[i++] = w[wi++];
		}
	}
	
	splitchar[i] = 0;
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
/* 주어진 문자열을 각 바이트별로 나눈다. */
/* hword = 입력 문자열 */
/* splitchar = 결과 저장 */
int split_by_byte (char *hword, char splitchar[][3]) {
	unsigned char* w = (unsigned char*) hword;
	int len = (int) strlen (hword);
	int wi = 0;
	int num_splitchar = 0;
	
	while (wi < len) {
			splitchar[num_splitchar][0] = w[wi++];
			splitchar[num_splitchar++][1] = 0;
	}
	
	return num_splitchar;
}
