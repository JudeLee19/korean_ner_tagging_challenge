#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#define B2TcBUFFER 32768

////////////////////////////////////////////////////////////////////////////
static int __CountNewline( char *str) 
{
  int num = 0;
  char *ptr = str;
  
  while (*ptr) 
  {
    if (*ptr == '\n') num++;
    ptr++;
  }
  return num;
}

////////////////////////////////////////////////////////////////////////////
// [리턴] 성공 : 1
int b2t_Save
(
  const char *InputFileName, // [입력] 입력 파일명(텍스트파일)
  const char *OutputFileName // [입력] 출력 파일명(바이너리파일)
)
{
  char *buffer;
  int len;
  char *contents;
  char **line_ptr;
  int cur_line = 0;
  FILE *infp, *outfp;
  long filesize;
  int num_line;

  int str_count = 0;
  int *str_index = NULL;

  int offset = 0;
  int i;
  char null_char = 0;

  // 파일 열기
  infp = fopen( InputFileName, "rb");
  assert( infp != NULL);
            
  /* 화일의 크기를 알아냄 */
  fseek(infp, 0, SEEK_END); /* 화일의 끝 */
  filesize = ftell(infp);   /* 화일의 위치 */
  fseek(infp, 0, SEEK_SET); /* 화일의 처음 */
                    
  contents = (char *) malloc( filesize+1); /* 메모리 할당 */
  assert( contents != NULL);

  fread( contents, filesize, 1, infp); /* 화일 전체를 읽어들임 */
  contents[filesize] = 0; /* NULL */
  fclose( infp); // 화일 닫기
  
  num_line = __CountNewline( contents); // 파일의 라인 수
  
  assert( num_line > 0);
  
  line_ptr = (char **) malloc( sizeof( char *) * num_line);
  assert( line_ptr != NULL);
                                        
  infp = fopen( InputFileName, "rt");
  assert( infp != NULL);
  
  buffer = (char *) malloc( sizeof (char) * B2TcBUFFER);
  assert( buffer != NULL);

  // 텍스트 파일 읽기
  while (fgets( buffer, B2TcBUFFER, infp) != (char *) NULL)
  {
    // remove trailing \n (like uniq(1))
    if (buffer[0] == '\0') continue;
    
    len = strlen( buffer);
    if (buffer[len-1] == '\n')
    {
      if (len == 1) continue;
      buffer[--len] = '\0';
    }
    
    // 문자열 저장
    line_ptr[cur_line] = (char *) malloc( sizeof( char) * (len + 1));
    assert( line_ptr[cur_line] != NULL);
    
    memcpy( line_ptr[cur_line], buffer, len + 1);
   
//    fprintf(stdout, "[%3d] %s\n", cur_line, line_ptr[cur_line]);
    cur_line++;
    
  }
  
  free( buffer);
  fclose( infp);
  
  // 바이너리 파일로 저장
  // 바이너리 파일 열기
  outfp = fopen( OutputFileName, "wb");
  assert( outfp != NULL);
  
  str_count = cur_line;
  assert( str_count > 0);
  
  str_index = (int *) malloc( sizeof(int) * str_count);
  assert( str_index != NULL);
  
  offset += sizeof(int) * (str_count + 1); // 1은 str_count를 위한 것
  assert( offset > 0);

  for (i = 0; i < str_count; i++) 
  {
    str_index[i] = offset;
    offset += strlen (line_ptr[i]) + 1; // 1은 NULL 문자를 위한 것
    assert( offset > 0);
  }
  
  // 문자열 수
  fwrite( &str_count, sizeof(int), 1, outfp);
  
  // 문자열 위치
  for (i = 0; i < str_count; i++) 
  {
    fwrite( &(str_index[i]), sizeof(int), 1, outfp);
  }
  
  // 문자열
  for (i = 0; i < str_count; i++) 
  {
    fwrite( line_ptr[i], strlen(line_ptr[i]), 1, outfp); // 1은 NULL 문자를 위한 것
    fwrite( &null_char, sizeof(char), 1, outfp);
//    fprintf(outfp, "%s%c", line_ptr[i], null_char); // 이렇게 해도 같은 효과

//**/    fprintf(stderr, "[%d] -> [%s]\n", str_index[i], line_ptr[i]);
  }
  
  fclose( outfp);
  
  // free 해야 함
  for (i = 0; i < str_count; i++)
  {
    free( line_ptr[i]);
  }
  
  free( contents);
  free( line_ptr);
  free( str_index);
    
  return 1;
}
