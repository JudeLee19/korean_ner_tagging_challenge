#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>

#include "dafst.h"
#include "bin2txt.h"
#include "fstdic.h"
#include "sort_uniq.h"

#define DEBUG

#define	FSTDICmFREE(x)	{ if((x)){ free(x); (x) = NULL;}}
  
///////////////////////////////////////////////////////////////////////////////
// 문자열 역순 복사
// 리턴값 : 복사한 문자의 수
static int __strRcpy
(
	char		*Dest,
	const char	*Src
)
{
	char *p = (char *)Src;
	char *q = Dest;
	
	// 문자열의 끝으로 이동
	while (*p) { p++; }
	
	while (Src < p)
	{
		*q++ = *(--p);
	}
	*q = 0;
	
	return (q - Dest);
}

///////////////////////////////////////////////////////////////////////////////
// 라인 -> key & value 쌍으로 만든다.
// key와 value는 tab으로 구분한다.
static int __LINEtoKeyValue
(
	char	**EntryTable,
	int	N,
	char	**Keys,
	char	**Values
)
{
	char *ptr;
	int i;
	
	for (i = 0; i < N; i++)
	{
		Keys[i] = EntryTable[i];
		
		if ((ptr = strchr( Keys[i], '\t')) == NULL)
		{
			fprintf( stderr, "Error: there is no TAB in line [%s]\n", ptr);
			return -1;
		}
		*ptr = 0;
		ptr++;
		
		if (strlen( ptr) == 0)
		{
			fprintf( stderr, "Error: there is no category in line [%s]\n", EntryTable[i]);
			return -1;
		}
		Values[i] = ptr;
	}
	return i;
}

///////////////////////////////////////////////////////////////////////////////
// 입력 파일이 정렬되어 있을 필요 없음
// return value : error = -1
int fstdic_Build
(
	const char	*InputFileName,	// [input]
	const char	*FileStem,		// [output]
	int		ReverseOn		// [input] 역방향 FST 구축 여부 (1 : 구축)
)
{
	int line_num = 0;
	char **entry_table = NULL; // 입력 라인들의 포인터
	char *content = NULL;			 // 입력 파일 내용
	
	char **keys = NULL;
	char **reverse_keys = NULL;
	char **values = NULL;
	char **arranged_values = NULL;
	char **arranged_keys = NULL;
	int  *rindex = NULL;
	void *fst = NULL;
	void *rfst = NULL;
	int i, j;
	int where_is = -1;
	int where_is2 = -1;
	int n;
	FILE *fp;
	FILE *rindex_fp;
	
	char temp_file[1024];
	char fst_file[1024];
	char rfst_file[1024];
	char info_file[1024];
	char rindex_file[1024];
	char list_file[1024];
	int ret;

#ifdef DEBUG
	fprintf( stderr, "Reading input file\n");
#endif	
	if ( (line_num = su_FILEtoLINES( InputFileName, &entry_table, &content)) <= 0)
	{
		ret = -1;
		goto Return;
	}
	
	keys = (char **)malloc( sizeof( char *) * line_num);
	if (keys == NULL)
	{
		ret = -1;
		goto Return;
	}
	
	if (ReverseOn)
	{
		reverse_keys = (char **)malloc( sizeof( char *) * line_num);
		if (keys == NULL)
		{
			ret = -1;
			goto Return;
		}
	}
	
	values = (char **)malloc( sizeof( char *) * line_num);
	if (values == NULL)
	{
		ret = -1;
		goto Return;
	}
	
#ifdef DEBUG
	fprintf( stderr, "Setting key-value pairs\n");
#endif	
	line_num = __LINEtoKeyValue( entry_table, line_num, keys, values);
	if (line_num < 0)
	{
		ret = -1;
		goto Return;
	}
	
#ifdef DEBUG
	fprintf( stderr, "Building FST\n");
#endif	
	// key-value 문자열
	// key값들로 FST 구축
	fst = fst_Compile( (const char **)keys, line_num);
	
	if (fst == NULL)
	{
		ret = -1;
		goto Return;
	}
	
	sprintf( fst_file, "%s%s", FileStem, FSTDIC_FST_NAME);

#ifdef DEBUG
	fprintf( stderr, "Saving FST file\n");
#endif	
	// FST 파일 저장	
	if ( !fst_Save( fst, fst_file, NULL)) 
	{
		fprintf( stderr, "ERROR :: cannot save FST to %s\n", fst_file);
		if (fst)
		{
			fst_Close( fst);
			fst = NULL;
		}
		ret = -1;
		goto Return;
	}
	
#ifdef DEBUG
	fprintf( stderr, "Indexing entries\n");
#endif	
	// 메모리 할당 (for value)
	arranged_values = (char **)malloc( sizeof( char *) * line_num);
	if (arranged_values == NULL)
	{
		ret = -1;
		goto Return;
	}
	// 초기화 (for value)
	arranged_values = memset( arranged_values, 0, sizeof( char *) * line_num);

	// 메모리 할당 (for key)
	arranged_keys = (char **)malloc( sizeof( char *) * line_num);
	if (arranged_keys == NULL)
	{
		ret = -1;
		goto Return;
	}

	// 모든 key값에 대해 value들의 위치(인덱스) 설정
	for (i = 0; i < line_num; i++)
	{
		where_is = fst_String2Hash( fst, keys[i], &n);
		
		if (where_is == FSTcNOT_EXIST)
		{
			fprintf( stderr, "Error: [%s] not found!\n", keys[i]);
			exit(1);
		}
		
		assert( where_is != FSTcNOT_EXIST);
		
		if (n == 1) // 중복키가 없는 경우 -> 바로 저장
		{
			arranged_values[where_is] = values[i];
			arranged_keys[where_is] = keys[i];
		}
		else // 중복키가 있는 경우
		{
			for (j = 0; j < n; j++) // 빈 자리가 발견되면 저장
			{
				if (arranged_values[where_is+j] == 0)
				{
					arranged_values[where_is+j] = values[i];
					arranged_keys[where_is+j] = keys[i];
					break;
				}
			}
		}
	}

	// reverse_key값들로 역FST 구축
	if (ReverseOn)
	{
#ifdef DEBUG
	fprintf( stderr, "Building reverse-FST\n");
#endif

		// reverse key값 생성
		for (i = 0; i < line_num; i++)
		{
			reverse_keys[i] = strdup( keys[i]); // 메모리 할당
			__strRcpy( reverse_keys[i], keys[i]); // 역으로 복사
		}
	
		// 역 FST 컴파일
		rfst = fst_Compile( (const char **)reverse_keys, line_num);
	
		if (rfst == NULL)
		{
			ret = -1;
			goto Return;
		}
	
		sprintf( rfst_file, "%s%s", FileStem, FSTDIC_RFST_NAME);

#ifdef DEBUG
	fprintf( stderr, "Saving reverse-FST file\n");
#endif	
		// FST 파일 저장	
		if ( !fst_Save( rfst, rfst_file, NULL)) 
		{
			fprintf( stderr, "ERROR :: cannot save FST to %s\n", rfst_file);
			if (rfst)
			{
				fst_Close( rfst);
				rfst = NULL;
			}
			ret = -1;
			goto Return;
		} 
	
#ifdef DEBUG
	fprintf( stderr, "Indexing reverse-entries\n");
#endif	
		// 메모리 할당 (역색인 정보)
		rindex = (int *)malloc( sizeof( int) * line_num);
		if (rindex == NULL)
		{
			ret = -1;
			goto Return;
		}
		rindex = memset( rindex, 0, sizeof( int) * line_num); 
		
		// 모든 reverse_key값에 대해 위치(인덱스) 설정
		for (i = 0; i < line_num; i++)
		{
			where_is = fst_String2Hash( rfst, reverse_keys[i], &n);
			assert( where_is != FSTcNOT_EXIST);
		
			where_is2 = fst_String2Hash( fst, keys[i], &n);
			assert( where_is2 != FSTcNOT_EXIST);
		
			if (n == 1) // 중복키가 없는 경우 -> 바로 저장
			{
				rindex[where_is] = where_is2;
			}
			else // 중복키가 있는 경우
			{
				for (j = 0; j < n; j++) // 빈 자리가 발견되면 저장
				{
					if (rindex[where_is+j] == 0)
					{
						rindex[where_is+j] = where_is2 + j;
						break;
					}
				}
			}
		}
		
#ifdef DEBUG
	fprintf( stderr, "Saving reverse-index file\n");
#endif	
		// 역 색인 파일에 저장
		sprintf( rindex_file, "%s%s", FileStem, FSTDIC_RINDEX_NAME);
		rindex_fp = fopen( rindex_file, "wb");
		assert( rindex_fp != NULL);
		fwrite( rindex, sizeof( int) * line_num, 1, rindex_fp);
		fclose( rindex_fp);
		
	} // if (ReverseOn)

#ifdef DEBUG
	fprintf( stderr, "Saving infomation file\n");
#endif	
	///////////////////////////////////////////////	
	// value들(string)을 텍스트 파일로 저장
	sprintf( temp_file, "%s.tmp", FileStem);
	fp = fopen( temp_file, "wt");
	assert( fp != NULL);

	for (i = 0; i < line_num; i++)
	{
		fprintf( fp, "%s\n", arranged_values[i]);
	}
	fclose( fp);
	
	sprintf( info_file, "%s%s", FileStem, FSTDIC_INFO_NAME);
	
	// 텍스트 파일을 바이너리 파일로 저장
	b2t_Save( temp_file, info_file);
	
	// 임시 파일 삭제
	remove( temp_file);

#ifdef DEBUG
	fprintf( stderr, "Saving entry file\n");
#endif	
	///////////////////////////////////////////////
	// key들(string)을 텍스트 파일로 저장
	sprintf( temp_file, "%s.tmp", FileStem);
	fp = fopen( temp_file, "wt");

	for (i = 0; i < line_num; i++)
	{
		fprintf( fp, "%s\n", arranged_keys[i]);
	}
	fclose( fp);
	
	sprintf( list_file, "%s%s", FileStem, FSTDIC_LIST_NAME);
	
	// 텍스트 파일을 바이너리 파일로 저장
	b2t_Save( temp_file, list_file);
	
	// 임시 파일 삭제
	remove( temp_file);

	///////////////////////////////////////////////
	// 메모리 해제
	if (fst)
	{
		fst_Close( fst);
		fst = NULL;
	}
	
	if (ReverseOn)
	{
		if (rfst)
		{
			fst_Close( rfst);
			rfst = NULL;
		}
	}
	
	// 성공
	ret = 1;
	
Return: 
	FSTDICmFREE( keys);
	FSTDICmFREE( values);
	FSTDICmFREE( arranged_values);
	FSTDICmFREE( arranged_keys);
	FSTDICmFREE( content);
	FSTDICmFREE( entry_table);
	
	if (ReverseOn)
	{
		for (i = 0; i < line_num; i++)
		{
			free( reverse_keys[i]);
		}
		FSTDICmFREE( reverse_keys);
		FSTDICmFREE( rindex);
	}

	return ret;
}
