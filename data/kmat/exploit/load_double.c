#include <stdio.h>
#include <stdlib.h>
#include <assert.h>

#include "probtool.h"

#ifdef WIN32
#undef USING_MMAP
#endif

#ifdef USING_MMAP
#include <sys/mman.h> // mmap
#include <sys/stat.h> // open
#include <fcntl.h> // open
#include <sys/types.h> // open
#include <unistd.h> // close
#endif

///////////////////////////////////////////////////////////////////////////////
#ifdef USING_MMAP
double *prob_LoadDouble
(
	const char *filename,
	int *FileSize
)
{
	double *probs;
	int file_size;
	
	int fileHandle = -1;
	struct stat statbuf;
	
	// 파일 열기
	fileHandle = open( filename, O_RDONLY);

	if (fstat (fileHandle, &statbuf) < 0)
	{
		fprintf(stderr, "fstat error\n");
		return NULL;
	}
	
	file_size = statbuf.st_size;
										
	// mmap
	probs = (double *) mmap( NULL, file_size, PROT_READ, MAP_SHARED, fileHandle, 0);
	assert( (void *) probs != MAP_FAILED);
	
//	/**/fprintf(stderr, "###### root = %p\n", probs);
					
	close( fileHandle); // 파일 닫기

	*FileSize = file_size;
	return probs;

}
#else
/*****************************************************************************/
// 파일로부터 double값들을 읽어들인다.
// 주의 : 메모리 해제를 함수 밖에서 해줘야 함
double *prob_LoadDouble
(
	const char *filename
)
{
	FILE *infofp;
	long file_size = 0;
	double *probs;

	if ((infofp = fopen (filename, "rb")) == NULL) 
	{
		fprintf (stderr, "ERROR: Can't open information file [%s]!\n", filename);
		return NULL;
	}

	fseek( infofp, 0, SEEK_END);
	file_size = ftell( infofp);
	fseek( infofp, 0, SEEK_SET);
	probs = (double *) malloc( file_size + 1);

	if (!probs) 
	{
		fprintf (stderr, "ERROR: Not enough memory!\n");
		return NULL;
	}
	
	//	fread( probs, sizeof (double), file_size / sizeof (double), infofp); // 읽기
	fread( probs, file_size, 1, infofp);
	
	fclose( infofp);
	
	return probs;
}
#endif

///////////////////////////////////////////////////////////////////////////////
#ifdef USING_MMAP
float *prob_LoadFloat
(
	const char *filename,
	int *FileSize
)
{
	float *probs;
	int file_size;
	
	int fileHandle = -1;
	struct stat statbuf;
	
	// 파일 열기
	fileHandle = open( filename, O_RDONLY);

	if (fstat (fileHandle, &statbuf) < 0)
	{
		fprintf(stderr, "fstat error\n");
		return NULL;
	}
	
	file_size = statbuf.st_size;
										
	// mmap
	probs = (float *) mmap( NULL, file_size, PROT_READ, MAP_SHARED, fileHandle, 0);
	assert( (void *) probs != MAP_FAILED);
	
//	/**/fprintf(stderr, "###### root = %p\n", probs);
					
	close( fileHandle); // 파일 닫기

	*FileSize = file_size;
	return probs;

}
#else
/*****************************************************************************/
// 파일로부터 float값들을 읽어들인다.
// 주의 : 메모리 해제를 함수 밖에서 해줘야 함
float *prob_LoadFloat
(
	const char *filename
)
{
	FILE *infofp;
	long file_size = 0;
	float *probs;

	if ((infofp = fopen (filename, "rb")) == NULL) 
	{
		fprintf (stderr, "ERROR: Can't open information file [%s]!\n", filename);
		return NULL;
	}

	fseek( infofp, 0, SEEK_END);
	file_size = ftell( infofp);
	fseek( infofp, 0, SEEK_SET);
	probs = (float *) malloc( file_size + 1);

	if (!probs) 
	{
		fprintf (stderr, "ERROR: Not enough memory!\n");
		return NULL;
	}
	
	//	fread( probs, sizeof (float), file_size / sizeof (float), infofp); // 읽기
	fread( probs, file_size, 1, infofp);
	
	fclose( infofp);
	
	return probs;
}
#endif
