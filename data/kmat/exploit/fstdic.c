#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <assert.h>
#include <fnmatch.h>

#include "dafst.h"
#include "bin2txt.h"
#include "binio.h"
#include "fstdic.h"

//#define DEBUG

#define	FSTDICmFREE(x)	{ if((x)){ free(x); (x) = NULL;}}
  
///////////////////////////////////////////////////////////////////////////////
// 파일이 존재하는가?
// 1 : 존재하는 경우, 0 : 존재하지 않는 경우
static int __IsExistFile
(
	const char *Filename
)
{
	FILE *fp = fopen( Filename, "rb");
	
	if (fp == NULL)
	{
		return 0;
	}
	fclose( fp);
	return 1;
}

///////////////////////////////////////////////////////////////////////////////
void fstdic_Close
(
	FSTDICtRSC *Rsc
)
{
	if (Rsc == NULL) return;

	if (Rsc->fst)
	{
		fst_Close( Rsc->fst);
		Rsc->fst = NULL;
	}

	if (Rsc->info)
	{
		b2t_Close( Rsc->info);
		Rsc->info = NULL;
	}
	
	if (Rsc->list)
	{
		b2t_Close( Rsc->list);
		Rsc->list = NULL;
	}
	
	if (Rsc->rfst)
	{
		fst_Close( Rsc->rfst);
		Rsc->rfst = NULL;
	}
	
	if (Rsc->rindex)
	{
		bin_Close( Rsc->rindex);
		Rsc->rindex = NULL;
	}

	FSTDICmFREE( Rsc);
}

///////////////////////////////////////////////////////////////////////////////
FSTDICtRSC *fstdic_Open
(
	const char *FileStemName // [input] 리소스 파일의 경로 (파일 stem명)
)
{
	char fst_file[1024];
	char info_file[1024];
	char list_file[1024];
	char rfst_file[1024];
	char rindex_file[1024];

	FSTDICtRSC *rsc = NULL;
	
	if (FileStemName == NULL || FileStemName[0] == 0) return NULL;

	sprintf( fst_file, "%s%s", FileStemName, FSTDIC_FST_NAME);
	sprintf( info_file, "%s%s", FileStemName, FSTDIC_INFO_NAME);
	sprintf( list_file, "%s%s", FileStemName, FSTDIC_LIST_NAME);
	
	sprintf( rfst_file, "%s%s", FileStemName, FSTDIC_RFST_NAME);
	sprintf( rindex_file, "%s%s", FileStemName, FSTDIC_RINDEX_NAME);

	rsc = (FSTDICtRSC *)malloc( sizeof( FSTDICtRSC));
	if (rsc == NULL) return NULL;
	
	// 초기화
	rsc->fst = NULL;
	rsc->info = NULL;
	rsc->list = NULL;
	rsc->rfst = NULL;
	rsc->rindex = NULL;

	// FST 파일 (essential)
	if ((rsc->fst = fst_Open( fst_file, NULL)) == NULL)
	{
		fprintf( stderr, "ERROR :: cannot open FST file (%s)\n", fst_file);
		fstdic_Close( rsc);
		return NULL;
	}
#ifdef DEBUG
	fprintf( stderr, "Loading %s [done]\n", fst_file);
#endif

	// info 파일 (essential)
	if (! __IsExistFile( info_file)) // 파일이 존재하지 않으면
	{
		fprintf( stderr, "ERROR :: cannot open infomation file (%s)\n", info_file);
		fstdic_Close( rsc);
		return NULL;
	}
	else
	{
		rsc->info = b2t_Open( info_file);

		if (rsc->info == NULL)
		{
			fstdic_Close( rsc);
			return NULL;
		}
	 
#ifdef DEBUG
		fprintf( stderr, "Loading %s [done]\n", info_file);
#endif 
	}
 
	// list 파일 (optional)
	if ( __IsExistFile( list_file)) // 파일이 존재하면
	{
		// 리스트 파일
		rsc->list = b2t_Open( list_file);

		if (rsc->list == NULL)
		{
			fprintf( stderr, "ERROR :: cannot open list file (%s)\n", list_file);
			fstdic_Close( rsc);
			return NULL;
		}
		
#ifdef DEBUG
		fprintf( stderr, "Loading %s [done]\n", list_file);
#endif 
	}
	
	// 역 FST 파일 (optional)
	if (__IsExistFile( rfst_file)) // 파일이 존재하면
	{
		if ((rsc->rfst = fst_Open( rfst_file, NULL)) == NULL)
		{
			fprintf( stderr, "ERROR :: cannot open FST file (%s)\n", rfst_file);
			fstdic_Close( rsc);
			return NULL;
		}
#ifdef DEBUG
		fprintf( stderr, "Loading %s [done]\n", rfst_file);
#endif
	}
	else rsc->rfst = NULL;
	
	// 역인덱스 파일 (optional)
	if (__IsExistFile( rindex_file)) // 파일이 존재하면
	{
		rsc->rindex = bin_Open( rindex_file);
		
		if (rsc->rindex == NULL)
		{
			fprintf( stderr, "ERROR :: cannot open bin file (%s)\n", rindex_file);
			fstdic_Close( rsc);
			return NULL;
		}
#ifdef DEBUG
		fprintf( stderr, "Loading %s [done]\n", rindex_file);
#endif

	}
	else rsc->rindex = NULL;
	
	return rsc;
}


///////////////////////////////////////////////////////////////////////////////
// Key값에 대응하는 value (문자열)를 리턴한다.
// key값은 unique하다고 가정
// (즉, 중복되는 key값이 있는 경우 가장 작은 hash값을 갖는 key값의 정보를 리턴)
// see also : fstdic_GetInfos
char *fstdic_GetInfo
(
	FSTDICtRSC *Rsc,
	const char *Key
)
{
	char *value;
	int n;
	int where_is = -1;
	
	if (Key[0] == 0) return NULL;
	
	where_is = fst_String2Hash( Rsc->fst, Key, &n);
	
	if (where_is != FSTcNOT_EXIST)
	{
		value = b2t_GetString( Rsc->info, where_is);
	}
	else
	{
		return NULL;
	}
	return value;
}

///////////////////////////////////////////////////////////////////////////////
// Key값에 대응하는 value (문자열)들을 찾는다.
// 리턴값 : value의 수 (0~), 오류 : -1
// see also : fstdic_GetInfo
int fstdic_GetInfos
(
	FSTDICtRSC	*Rsc,		 // [input]
	const char	*Key,		 // [input]
	char		**Values, // [output]
	int		MaxValue	// [input] Values의 최대 수
)
{
	int n; // 발견된 value의 수
	int where_is = -1;
	int i;
	
	if (Key[0] == 0) return -1;
	
	where_is = fst_String2Hash( Rsc->fst, Key, &n);
	
	if (where_is == FSTcNOT_EXIST) return 0; // 찾지 못한 경우
	
	// 찾은 경우
	for (i = 0; i < n && i < MaxValue; i++)
	{
		Values[i] = b2t_GetString( Rsc->info, where_is+i);
	}
	return i;
}

///////////////////////////////////////////////////////////////////////////////
// 문자열 역순 복사
// 리턴값 : 복사한 문자의 수
static int __strRcpy
(
	char		*Dest,
	const char	*Src
)
{
	char *p = (char *)Src;
	char *q = Dest;
	
	// 문자열의 끝으로 이동
	while (*p) { p++; }
	
	while (Src < p)
	{
		*q++ = *(--p);
//		/**/fprintf( stderr, "%d\n", *p);
	}
	*q = 0;
	
	return (q - Dest);
}

///////////////////////////////////////////////////////////////////////////////
// Key값에 대응하는 value (문자열)들을 찾는다.
// 리턴값 : value의 수 (0~), 오류 : -1
// see also : fstdic_GetInfo
int fstdic_rGetInfos
(
	FSTDICtRSC	*Rsc,		 // [input]
	const char	*Key,		 // [input]
	char		**Values, // [output]
	int		MaxValue	// [input] Values의 최대 수
)
{
	int n; // 발견된 value의 수
	int where_is = -1;
	int i;
	
	if (Key[0] == 0) return -1;
	
	char reverse_key[1024];
	
	__strRcpy( reverse_key, Key);
	
	where_is = fst_String2Hash( Rsc->rfst, reverse_key, &n);
	
	if (where_is == FSTcNOT_EXIST) return 0; // 찾지 못한 경우
	
	// 찾은 경우
	for (i = 0; i < n && i < MaxValue; i++)
	{
		Values[i] = b2t_GetString( Rsc->info, bin_GetEntryInt( Rsc->rindex, where_is+i));
	}
	return i;
}

///////////////////////////////////////////////////////////////////////////////
void fstdic_FreeKeyValue
(
	FSTDICtSTORE *KeyValue
)
{
	if (KeyValue)
	{
		FSTDICmFREE( KeyValue->values);
		FSTDICmFREE( KeyValue->keys);
		FSTDICmFREE( KeyValue);
	}
}

///////////////////////////////////////////////////////////////////////////////
FSTDICtSTORE *fstdic_NewKeyValue
(
	int MaxKeyValue
)
{
	FSTDICtSTORE *store = (FSTDICtSTORE *)malloc( sizeof( FSTDICtSTORE));
	if (store == NULL) return NULL;
	
	store->keys = (char **)malloc( sizeof( char *) * MaxKeyValue);
	if (store->keys == NULL)
	{
		fstdic_FreeKeyValue( store);
		return NULL;
	}
	
	store->values = (char **)malloc( sizeof( char *) * MaxKeyValue);
	if (store->values == NULL)
	{
		fstdic_FreeKeyValue( store);
		return NULL;
	}
	
	store->capacity = MaxKeyValue;
	store->count = 0; 
	
	return store;
}

////////////////////////////////////////////////////////////////////////////////
typedef struct {
	FSTDICtSTORE *store;
	FSTDICtRSC *rsc;
} FSTDICtTEMP;

////////////////////////////////////////////////////////////////////////////////
// pParam : 패턴
// s : 패턴과 일치하는 문자열
// Hash : s에 대응하는 해쉬값
static int __TraverseCallback
(
	void		*pParam,
	const char	*S,
	int		Hash
)
{
	FSTDICtSTORE *store = ((FSTDICtTEMP *)pParam)->store;
	FSTDICtRSC *rsc = ((FSTDICtTEMP *)pParam)->rsc;

	if (store->capacity <= store->count)
	{
		return 1; // 저장하지 않고 리턴 // -1을 리턴하면 탐색 종료
	}
	store->keys[store->count] = b2t_GetString( rsc->list, Hash);
	store->values[store->count++] = b2t_GetString( rsc->info, Hash);
	
	return 1;
}

////////////////////////////////////////////////////////////////////////////////
// pParam : 패턴
// s : 패턴과 일치하는 문자열
// Hash : s에 대응하는 해쉬값
static int __TraverseCallback_R
(
	void		*pParam,
	const char	*S,
	int		Hash
)
{
	FSTDICtSTORE *store = ((FSTDICtTEMP *)pParam)->store;
	FSTDICtRSC *rsc = ((FSTDICtTEMP *)pParam)->rsc;
	
	if (store->capacity <= store->count)
	{
		return 1; // 저장하지 않고 리턴 // -1을 리턴하면 탐색 종료
	}
	store->keys[store->count] = b2t_GetString( rsc->list, bin_GetEntryInt( rsc->rindex, Hash));
	store->values[store->count++] = b2t_GetString( rsc->info, bin_GetEntryInt( rsc->rindex, Hash));
	
	return 1;
}

///////////////////////////////////////////////////////////////////////////////
int fstdic_fnmatch
(
	FSTDICtRSC	 *Rsc,	// [input]
	const char	 *Pattern,	// [input]
	FSTDICtSTORE *KeyValue	// [output]
)
{
	int i;
	int count = 0; // KeyValue->count;
	char *key;
	int num_line = fst_GetNumberOfEntry( Rsc->fst);

	for (i = 0; i < num_line; i++)
	{
		 
		key = b2t_GetString( Rsc->list, i);
		
		if (fnmatch( Pattern, key, FNM_NOESCAPE) == 0) // found
		{
			if (count >= KeyValue->capacity)
			{
				count++;
				continue;
			}
		
			KeyValue->keys[count] = key;
			KeyValue->values[count++] = b2t_GetString( Rsc->info, i);
			KeyValue->count = count;
		}
	}
	return count;
}

///////////////////////////////////////////////////////////////////////////////
int fstdic_GetInfosWithPattern
(
	FSTDICtRSC		*Rsc,		// [input]
	const char		*Pattern,	// [input]
	FSTDICtSTORE	*KeyValue,	// [output]
	int			MaxValue	// [input] Values의 최대 수
)
{
	int fwd = 5;
	int bwd = 5;
	int len = strlen( Pattern);
	FSTDICtTEMP rsc_keyvalue;
	int ret;
	
	if (Rsc->info == NULL || Rsc->fst == NULL || Rsc->rfst == NULL || Rsc->rindex == NULL || Rsc->list == NULL)
	{
		fprintf( stderr, "Unsupported function (fstdic_GetInfosWithPattern)\n");
		return -1;
	}
	
	rsc_keyvalue.rsc = Rsc;
	rsc_keyvalue.store = KeyValue;
	
	if (Rsc->rfst == NULL) bwd = 2;
	
	// "*xxx" : 후방탐색
	// "xxx*" : 전방탐색
	if (Pattern[0] == '*') fwd -= 2;
	else if (Pattern[0] == '?') fwd -= 1;

	if (Pattern[len-1] == '*') bwd -= 2;
	else if (Pattern[len-1] == '?') bwd -= 1;
	
	if (fwd == 3 && (bwd == 3 || bwd == 0)) // *xxx* 유형
	{
#ifdef DEBUG
		fprintf( stderr, "<<양방향>>\n");
#endif
		ret = fstdic_fnmatch( Rsc, Pattern, KeyValue);
		return ret;
	}
	
	if (fwd >= bwd)
	{
		// 전방 탐색
		ret = fst_Pattern2Hash( Rsc->fst, Pattern, &rsc_keyvalue, __TraverseCallback);
	}
	else
	{
#ifdef DEBUG
		fprintf( stderr, "<<역방향>>\n");
#endif
		// 후방 탐색
		char *rPattern = (char *)malloc( sizeof( char) * (len+1));
		__strRcpy( rPattern, Pattern);

		ret = fst_Pattern2Hash( Rsc->rfst, rPattern, &rsc_keyvalue, __TraverseCallback_R);

		free( rPattern);
	}
	
	return ret;
}
