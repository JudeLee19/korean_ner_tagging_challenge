// mmap을 사용하고자 할 때 선언
#define USE_MMAP

#include <stdio.h>
#include <stdlib.h>

#ifdef WIN32
  #undef USE_MMAP
#else
  #include <unistd.h> // close
  #include <sys/stat.h> // open
  #include <fcntl.h> // open
#endif

#ifdef USE_MMAP
  #include <sys/mman.h> // mmap
#endif

typedef struct {
  void *mmap_root;
  int mmap_size;
} BINtFILE;

/////////////////////////////////////////////////////////////////////
#ifndef USE_MMAP
// 파일 크기 반환
// [리턴] 파일 크기 (-1: 에러)
static int __Get_FileSize
(
  const char *Filename // [입력] 파일 명
)
{
  int filesize = 0;
  FILE *fp;

  if ((fp = fopen( Filename, "rb")) == NULL)
  {
    if (fp == NULL) return -1;
  }

  // 화일의 크기를 알아냄
  fseek( fp, 0, SEEK_END); // 화일의 끝
  filesize = ftell( fp);   // 화일의 위치
  fseek( fp, 0, SEEK_SET); // 화일의 처음

  fclose( fp);
  
  return filesize;
}
#endif

///////////////////////////////////////////////////////////////////////////////
// int, double 등과 같은 고정 길이 자료 구조에만 사용할 수 있음
// char *와 같은 가변 길이 자료 구조는 libbin2txt를 사용할 것
// [리턴] 구조체 : 성공, NULL : 실패
void *bin_Open
(
  const char *Filename
)
{

  BINtFILE *stream;

  void *contents;
  int filesize;

#ifdef USE_MMAP ///////////////////////////////////////////////////////
  int fileHandle = -1;
  struct stat statbuf;

  // 파일 열기
  fileHandle = open( Filename, O_RDONLY);

  if (fstat (fileHandle, &statbuf) < 0)
  {
//    fprintf(stderr, "fstat error\n");
    return NULL;
  }

  // 파일 크기 알아내기
  filesize = statbuf.st_size;
  
  if (filesize <= 0) return NULL;

  // mmap
  contents = (void *) mmap( NULL, filesize, PROT_READ, MAP_SHARED, fileHandle, 0);
  
  if ((void *) contents == MAP_FAILED) return NULL;

//  /**/fprintf(stderr, "###### root = %p\n", contents);

  close( fileHandle); // 파일 닫기

#else ////////////////////////////////////////////////////////////////
  FILE *infp;

  // 화일의 크기를 알아냄
  filesize = __Get_FileSize( Filename);
  if (filesize == -1) return NULL;
  
  // 바이너리 파일 읽기
  
  infp = fopen( Filename, "rb"); /* 화일 열기 */
  if (infp == NULL) return NULL;
  
  contents = (char *) malloc( filesize); // 메모리 할당
  if (contents == NULL) return NULL;
  
  fread( contents, filesize, 1, infp); // 화일 전체를 읽어들임
  fclose( infp); // 화일 닫기
#endif ////////////////////////////////////////////////////////////////

  stream = (BINtFILE *) malloc( sizeof( BINtFILE)); // memory allocation
  if (stream == NULL) return NULL;
  
  stream->mmap_root = contents;
  stream->mmap_size = filesize;
  
  return (void *)stream;
}

///////////////////////////////////////////////////////////////////////////////
// [리턴] 1: 성공, 0: 실패
int bin_Close
(
  void *Rsc
)
{
  BINtFILE *stream = (BINtFILE *)Rsc;

#ifdef USE_MMAP
  if ( munmap( (void *)stream->mmap_root, stream->mmap_size) == -1)
  {
    if (Rsc) 
    {
      free( Rsc);
      Rsc = NULL; 
    }
    return 0;
  }
#else
  // 메모리 해제
  if ( stream->mmap_root)
  {
    free( stream->mmap_root); // 이거 하나로 해결
    stream->mmap_root = NULL;
  }
  stream->mmap_size = 0;
#endif
  
  if (Rsc) 
  {
    free( Rsc);
    Rsc = NULL;
  }
  
  return 1;
}

///////////////////////////////////////////////////////////////////////////////
// 저장되어 있는 자료(entry)의 수를 알아낸다.
// [return] the number of entries
int bin_GetCount
(
  void *Rsc,
  int SizeOfData
)
{
   BINtFILE *stream = (BINtFILE *)Rsc;
   
  if (SizeOfData < 0) return 0;
  
  return (stream->mmap_size / SizeOfData);
}

///////////////////////////////////////////////////////////////////////////////
// int형의 자료를 얻기 위한 함수 (N번째 위치에서 찾는다.)
int bin_GetEntryInt
(
  void *Rsc,
  int N
)
{
  BINtFILE *stream = (BINtFILE *)Rsc;
  
  return  ((int *)stream->mmap_root)[N];
}

//////////////////////////////////////////////////////////////////////////////
// float형의 자료를 얻기 위한 함수 (N번째 위치에서 찾는다.)
float bin_GetEntryFloat
(
  void *Rsc,
  int N
)
{
  BINtFILE *stream = (BINtFILE *)Rsc;

  return  ((float *)stream->mmap_root)[N];
}

//////////////////////////////////////////////////////////////////////////////
// double형의 자료를 얻기 위한 함수 (N번째 위치에서 찾는다.)
double bin_GetEntryDouble
(
  void *Rsc,
  int N
)
{
  BINtFILE *stream = (BINtFILE *)Rsc;

  return  ((double *)stream->mmap_root)[N];
}

//////////////////////////////////////////////////////////////////////////////
// Rsc에 저장되어 있는 N 위치에 있는 자료를 얻기 위한 함수
// Callback : 사용자 함수
// [리턴] Callback 함수가 리턴해 주는 void 포인터
void *bin_GetEntry
(
  void *Rsc,
  int N, 
  void *(*Callback)(void *, int )
)
{
  BINtFILE *stream = (BINtFILE *)Rsc;

  return Callback( stream->mmap_root, N);
}
